<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>R&D: Render Engine</title>
<link rel="stylesheet" href="style.css" />
</head>

<header>
    <img src="icons/logo.png" alt="Website Logo" class="logo" onclick="location.href='index.html'">

  <a href="https://github.com/AndrewWhatling" target="_blank">
    <img src="icons/github.svg" alt="Github link" class="github">
  </a>

  <a href="https://www.linkedin.com/in/andrew-whatling-2704a6259" target="_blank">
    <img src="icons/linkedin.svg" alt="Linkedin link" class="linkedin">
  </a>
</header>

<body>

  <div class="container portfolio-container">

    <div class="portfolio-text-double box">
      <h2>Helix - Custom CPU Based Render Engine</h2>
      <p>
        <br>
        Helix is a CPU rendering software I started briefly in summer, and since late September 2025, have
        dedicated a lot more time to. There were several reasons as to why I wanted to take on this
        project, I was originally inspired by Sebastian Lague's "Coding Adventure" series, especially
        his raytracer and fluid solver projects.
        <br><br>
      </p>
      <p>
        This project also opened up a variety of learning opportunities and new challenges for me. At the time,
        I had recently gotten a new laptop, and setup Arch Linux for the first time. As well as this, I also started
        using Neovim, a text editor with a lot of keyboard-centric flexibility and a steep learning curve. This
        project gave me the perfect excuse to sink hours into learning, as well as getting comfortable with all of
        these new concepts.
      </p>
      <p>
        <br>
        Now one of the first questions I get when I talk about my render engine is 'Why call it "Helix?"'.
        Whenever I imagine the word helix, the first thing that comes to mind is DNA, or a "double helix".
        This project was my first time using C++, I wanted to challenge myself, and had the drive to create
        this project, so having to learn a new programming language wasn't going to stop me. One of the first
        questions I had when first learning C++ was, "What's a double?", turns out it's a float with double the
        precision, and that's where the idea first came from to call it Helix, and it's stuck ever since.
      </p>
      <p>
        <br>
        Below are my latest renders, as well as the journey that got me here.
      </p>
    </div>

    <div class="portfolio-text-double box">
      <h2>Latest Render</h2>
    </div>

    <div class="portfolio-photo-double">
      <img src="images/renders/cornell_box_metal_dragon_glass.png" alt="Render" />
    </div>
    
    <div class="portfolio-text-double box">
      <h2>Data Passes</h2>
      <h3>
        Current working passes - Cryptomatte object/material, Depth, World space Position, 
        Normals and Camera Facing Ratio.
      </h3>
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/data_pass_cryptomatte.png" alt="Cryptomatte" />
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/data_pass_depth.png" alt="Depth" />
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/data_pass_world_space_position.png" alt="World Space Position" />
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/data_pass_normals.png" alt="Normals" />
    </div>

    <div class="portfolio-photo-double">
      <img src="images/renders/data_pass_facing_ratio.png" alt="Camera Facing Ratio" />
    </div>

    <div class="portfolio-text-double box">
      <h2>Depth Of Field</h2>
      <h3>
        Using a thin-lens camera model, default settings for the Black Magic Mini Ursa 4.6K.
      </h3>
    </div>

    <div class="portfolio-photo-double">
      <img src="images/renders/two_dragons_fov_30_2025_oct_27th_10_38.png" alt="Render" />
    </div>

    <div class="portfolio-text-double box">
      <h2>Material Types</h2>
      <h3>
        Current working Materials - Lambertian (Matte), Metallic, Dielectric (Glass) and Emissive.
      </h3>
    </div>
    
    <div class="portfolio-photo">
      <img src="images/renders/purple_dragon.png" alt="Render" />
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/lambert_two_dragons_400_primary_2025_oct_27th_10_37.png" alt="Render" />
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/metallic_two_dragons_400_primary_2025_oct_27th_11_06.png" alt="Render" />
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/sphere_light_2025_oct_27th_16_01.png" alt="Render" />
    </div>


    <div class="portfolio-text-double box">
      <h2>The Journey</h2>
    </div>

    <div class="portfolio-text box">
      <p>
        I started my render engine off by initially following along a series called "Raytracing in one weekend." 
        I ran through the initial few chapters of that series. This started with creating very basic images, and 
        exporting through a format called PPM. After that was adding a basic sphere into the scene, not as geometry,
        but as the mathematical representation. Once that was working, I added basic anti-aliasing and reading of what
        would be the normals of the sphere, and that finally lead to the image you see here.
      </p>
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/antialiasing_2025_sept_30th_12_08.png" alt="Sphere with normals " />
    </div>

    <div class="portfolio-text box">
      <p>
        Once that was complete, the next step was to actually get some form of basic shading. I used a very basic
        shading model to start off with, and the first material type I went with was "Lambertian", a lambert shader, 
        commonly refered to as "Matte shading". This refers to a perfectly diffuse material.
      </p>
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/lambert_shadows_2025_oct_01st_01_41.png" alt="Lambert material" />
    </div>

    <div class="portfolio-text box">
      <p>
        This wasn't without issue however. During this I had a error in my code when it came to the calculation of 
        how ambient light should interact with the sphere's that I had. This resulted in the spheres coming out as 
        a flat grey color with no observable depth to them.
      </p>
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/greyball_no_shadows_2025_oct_01st_01_03.png" alt="Greyballs no depth" />
    </div>

    <div class="portfolio-text box">
      <p>
        The next material type on the list was metals. The shading model I was using took in 2 parameters for metals. 
        First was the color of the metal in RGB, and the second was a 0 to 1 range value called "Fuzz", essentially how 
        blurred the metal's reflection was.
      </p>
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/metal_lambertian_2025_oct_02nd_14_27.png" alt="Metal spheres" />
    </div>

    <div class="portfolio-text box">
      <p>
        After that was programming in a transparent material. The type of transparency I am using is a pure Dielectric model.
        More specifically I am only using Index of Refraction (IOR) to affect the level of transparency that the material has.
        I decided to add a second sphere within the first glass sphere, so that the material can act as though it has thickness,
        rather than just being a solid block of glass.
      </p>
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/dialectrics_bubble_2025_oct_05th_22_06.png" alt="Glass bubble sphere" />
    </div>

    <div class="portfolio-text box">
      <p>
        Once I had those materials sorted, it was time to make the camera movable. The main challenge with this was that in order 
        to render objects, you first have to convert the world from world space to camera space (space where the camera is at the 
        center of the world), and from there you then convert to 2D pixel space, so applying a transformation to the camera meant 
        adding the world to camera space transformation as well.
      </p>
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/camera_lookat_oct_07th_22_14.png" alt="Camera moved" />
    </div>

    <div class="portfolio-text box">
      <p>

      </p>
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/depth_of_field_2025_oct_07th_23_26.png" alt="Depth of Field" />
    </div>

    <div class="portfolio-text box">
      <p>

      </p>
    </div>

    <div class="portfolio-photo">
      <img src="images/renders/raytracing_in_one_weekend_complete_2025_oct_08th_03_06.png" alt="Finished Raytracing In One Weekend" />
    </div>


    <div style="height: 1px;"></div>
  </div>
  


</body>

</html>
